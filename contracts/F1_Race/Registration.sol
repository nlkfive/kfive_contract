// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "./IRegistrationList.sol";
import "../common/AccessControl.sol";
import "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
import "./IRaceList.sol";
import "./IRace.sol";

contract RegistrationList is
    VRFConsumerBase,
    IRace,
    KfiveAccessControl,
    IRegistrationList
{
    using Address for address;
    IRaceList private _raceList;
    IERC721Enumerable private _nlggt;
    // The contract will contain multiple objects. 
    // Each oracle job has a unique key hash that identifies the tasks that it should perform. 
    // The contract will store the Key Hash that identifies Chainlink VRF and the fee amount to use in the request.
    bytes32 private s_keyHash;
    uint256 private s_fee;

    bytes32 private constant RANDOM_IN_PROGRESS = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;

    // Binance Smart Chain Mainnet - https://docs.chain.link/docs/vrf-contracts/#binance-smart-chain-mainnet
    // LINK Token	0x404460C6A5EdE2D891e8297795264fDe62ADBB75
    // VRF Coordinator	0x747973a5A2a4Ae1D3a8fDF5479f1514F65Db9C31
    // Key Hash	0xc251acd21ec4fb7f31bb8868288bfdbaeb4fbfec2df3735ddbd4f7dc8d60103c
    // Fee	0.2 LINK - initial fees on BSC are meant to cover the highest gas cost prices.
    constructor(
        address vrfCoordinator,
        address link,
        address nlggt,
        address raceList,
        bytes32 keyHash, 
        uint256 fee
    ) VRFConsumerBase(vrfCoordinator, link) {
        require(nlggt.isContract(), "Invalid NLGGT");
        require(raceList.isContract(), "Invalid RaceList");
        _raceList = IRaceList(raceList);
        _nlggt = IERC721Enumerable(nlggt);
        s_keyHash = keyHash;
        s_fee = fee;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(AccessControlEnumerable, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(IRegistrationList).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    ////////////////////////////////////////////////////////////
    // Participants list
    ////////////////////////////////////////////////////////////
    // From raceId => (slotId => (index => participant address))
    mapping(bytes32 => mapping(uint256 => mapping(uint8 => address))) private registrationList;
    // Random number (32 bytes = 32 slots) - Using for select selected participants
    // byte index 1 => slot 1 (L2R)
    // byte index 2 => slot 2
    // ...
    // byte index 32 => slot 32
    // Selected participant at slot 1 = byte 1 modulo total registered in slot 1
    // From raceId => random number generated by chainlink
    mapping(bytes32 => bytes32) private randomSelected;
    // Count total registered (32 bytes = 32 slots) - Maximum each slot is 255
    // byte index 1 => slot 1 (L2R)
    // byte index 2 => slot 2
    // ...
    // byte index 32 => slot 32
    // From raceId => total registered bytes array
    mapping(bytes32 => bytes32) private totalRegistered;
    // From vrf request id to running raceId
    mapping(bytes32 => bytes32) private vrfRandomMap;

    /**
     * @dev Register to be a participant
     * Participant must be an nlggt holder
     */
    function register(
        uint256 slotId,
        bytes32 raceId
    )
        external 
        override
        whenNotPaused
    {
        require(_nlggt.balanceOf(_msgSender()) > 0, "Not NLGGT holder");
        Race memory _race = _raceList.getRace(raceId);
        require(_race.betStarted != 0, "Not existed");
        require(slotId < _race.slots, "Invalid slot");
        onlyAfter(_race.betStarted);
        onlyBefore(_race.betEnded);
        uint8 totalRegisteredAtSlot = uint8(totalRegistered[raceId][slotId]);
        require(totalRegisteredAtSlot < 255, "Maximum reached");

        registrationList[raceId][slotId][totalRegisteredAtSlot + 1] = _msgSender();
        totalRegistered[raceId] = increaseAtIndex(totalRegistered[raceId], slotId);
        emit Registered(slotId, _msgSender(), raceId);
    }

    /**
     * @dev Select random participants for race from registered list for each slot
     */
    function selectParticipant(bytes32 raceId)
        external 
        override
        whenNotPaused
        onlyRole(ADMIN_ROLE) returns (bytes32 requestId)
    {
        // checking LINK balance
        require(LINK.balanceOf(address(this)) >= s_fee, "Not enough LINK to pay fee");
        // checking participant at slot is already selected
        require(randomSelected[raceId] == 0, "Already selected");
        // check if race is existed
        Race memory _race = _raceList.getRace(raceId);
        require(_race.betStarted != 0, "Not existed");
        onlyAfter(_race.betEnded);
        // requesting randomness
        requestId = requestRandomness(s_keyHash, s_fee);
        // storing requestId and raceId
        vrfRandomMap[requestId] = raceId;
        randomSelected[raceId] = RANDOM_IN_PROGRESS;

        emit RandomInProgress(raceId);
    }

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override 
    {
        bytes32 raceId = vrfRandomMap[requestId];
        randomSelected[raceId] = modBytes(totalRegistered[raceId], bytes32(randomness));
        // Mark this race has selected participants
        randomSelected[raceId] |= bytes32(uint256(0xff));
        emit ParticipantsSelected(requestId, raceId, randomness, randomSelected[raceId]);
    }

    /**
     * @dev Receive reward after race ended.
     */
    function receiveReward(bytes32 raceId, uint256 slotId) 
        external 
        override
        whenNotPaused
    {
        require(totalRegistered[raceId][slotId] != bytes1(0), "Invalid slot");
        require(randomSelected[raceId] != bytes32(0), "Invalid race");
        // address slotWinner = registrationList[raceId][slotId][index][uint8(randomSelected[raceId][slotId])];
        // require(slotWinner != _msgSender(), "Invalid winner");
        // TODO: get reward
    }

    /**
     * @dev Update race address
     */
    function updateRaceAddress(address raceList)
        external 
        override
        onlyRole(ADMIN_ROLE)
        whenNotPaused
    {
        _raceList = IRaceList(raceList);
        emit RaceListUpdated(raceList);
    }

    /**
     * @dev Update nlggt address
     */
    function updateNlggtAddress(address nlggt)
        external
        override
        onlyRole(ADMIN_ROLE)
        whenNotPaused
    {
        _nlggt = IERC721Enumerable(nlggt);
        emit NlggtUpdated(nlggt);
    }

    function onlyBefore(uint256 _time) internal view {
        if (block.timestamp >= _time) revert TooLate(_time);
    }

    function onlyAfter(uint256 _time) internal view {
        if (block.timestamp <= _time) revert TooEarly(_time);
    }

    // 0 < index < 31
    function increaseAtIndex(bytes32 input, uint256 index) internal pure returns (bytes32) {
        return bytes32(uint256(input) + (1 << ((31 - index) * 8)));
    }

    // Random select index from participant bytes array
    function modBytes(bytes32 _totalRegistered, bytes32 random) internal pure returns (bytes32 result) {
        for (uint256 slotId = 0; slotId < 32; slotId++) {
            if (uint8(_totalRegistered[slotId]) > 0){
                result |= bytes32(uint256(uint8(random[slotId]) % uint8(_totalRegistered[slotId]))) << (8 * (32 - slotId));
            }
        }
    }

    function selectedParticipants(bytes32 raceId) 
        external 
        view
        returns (bytes32)
    {
        return randomSelected[raceId];
    }

    function selectedParticipant(bytes32 raceId, uint256 slotId) 
        external 
        view
        returns (bytes1)
    {
        return randomSelected[raceId][slotId];
    }
}
